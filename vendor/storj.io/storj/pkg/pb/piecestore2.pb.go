// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: piecestore2.proto

package pb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
	drpc "storj.io/drpc"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PieceHeader_FormatVersion int32

const (
	PieceHeader_FORMAT_V0 PieceHeader_FormatVersion = 0
	PieceHeader_FORMAT_V1 PieceHeader_FormatVersion = 1
)

var PieceHeader_FormatVersion_name = map[int32]string{
	0: "FORMAT_V0",
	1: "FORMAT_V1",
}

var PieceHeader_FormatVersion_value = map[string]int32{
	"FORMAT_V0": 0,
	"FORMAT_V1": 1,
}

func (x PieceHeader_FormatVersion) String() string {
	return proto.EnumName(PieceHeader_FormatVersion_name, int32(x))
}

func (PieceHeader_FormatVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{8, 0}
}

// Expected order of messages from uplink:
//   OrderLimit ->
//   repeated
//      Order ->
//      Chunk ->
//   PieceHash signed by uplink ->
//      <- PieceHash signed by storage node
//
type PieceUploadRequest struct {
	// first message to show that we are allowed to upload
	Limit *OrderLimit `protobuf:"bytes,1,opt,name=limit,proto3" json:"limit,omitempty"`
	// order for uploading
	Order *Order                    `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
	Chunk *PieceUploadRequest_Chunk `protobuf:"bytes,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
	// final message
	Done                 *PieceHash `protobuf:"bytes,4,opt,name=done,proto3" json:"done,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PieceUploadRequest) Reset()         { *m = PieceUploadRequest{} }
func (m *PieceUploadRequest) String() string { return proto.CompactTextString(m) }
func (*PieceUploadRequest) ProtoMessage()    {}
func (*PieceUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{0}
}
func (m *PieceUploadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceUploadRequest.Unmarshal(m, b)
}
func (m *PieceUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceUploadRequest.Marshal(b, m, deterministic)
}
func (m *PieceUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceUploadRequest.Merge(m, src)
}
func (m *PieceUploadRequest) XXX_Size() int {
	return xxx_messageInfo_PieceUploadRequest.Size(m)
}
func (m *PieceUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PieceUploadRequest proto.InternalMessageInfo

func (m *PieceUploadRequest) GetLimit() *OrderLimit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *PieceUploadRequest) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *PieceUploadRequest) GetChunk() *PieceUploadRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *PieceUploadRequest) GetDone() *PieceHash {
	if m != nil {
		return m.Done
	}
	return nil
}

// data message
type PieceUploadRequest_Chunk struct {
	Offset               int64    `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceUploadRequest_Chunk) Reset()         { *m = PieceUploadRequest_Chunk{} }
func (m *PieceUploadRequest_Chunk) String() string { return proto.CompactTextString(m) }
func (*PieceUploadRequest_Chunk) ProtoMessage()    {}
func (*PieceUploadRequest_Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{0, 0}
}
func (m *PieceUploadRequest_Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceUploadRequest_Chunk.Unmarshal(m, b)
}
func (m *PieceUploadRequest_Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceUploadRequest_Chunk.Marshal(b, m, deterministic)
}
func (m *PieceUploadRequest_Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceUploadRequest_Chunk.Merge(m, src)
}
func (m *PieceUploadRequest_Chunk) XXX_Size() int {
	return xxx_messageInfo_PieceUploadRequest_Chunk.Size(m)
}
func (m *PieceUploadRequest_Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceUploadRequest_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_PieceUploadRequest_Chunk proto.InternalMessageInfo

func (m *PieceUploadRequest_Chunk) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PieceUploadRequest_Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type PieceUploadResponse struct {
	Done                 *PieceHash `protobuf:"bytes,1,opt,name=done,proto3" json:"done,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PieceUploadResponse) Reset()         { *m = PieceUploadResponse{} }
func (m *PieceUploadResponse) String() string { return proto.CompactTextString(m) }
func (*PieceUploadResponse) ProtoMessage()    {}
func (*PieceUploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{1}
}
func (m *PieceUploadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceUploadResponse.Unmarshal(m, b)
}
func (m *PieceUploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceUploadResponse.Marshal(b, m, deterministic)
}
func (m *PieceUploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceUploadResponse.Merge(m, src)
}
func (m *PieceUploadResponse) XXX_Size() int {
	return xxx_messageInfo_PieceUploadResponse.Size(m)
}
func (m *PieceUploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceUploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PieceUploadResponse proto.InternalMessageInfo

func (m *PieceUploadResponse) GetDone() *PieceHash {
	if m != nil {
		return m.Done
	}
	return nil
}

// Expected order of messages from uplink:
//   {OrderLimit, Chunk} ->
//   go repeated
//      Order -> (async)
//   go repeated
//      <- PieceDownloadResponse.Chunk
type PieceDownloadRequest struct {
	// first message to show that we are allowed to upload
	Limit *OrderLimit `protobuf:"bytes,1,opt,name=limit,proto3" json:"limit,omitempty"`
	// order for downloading
	Order *Order `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
	// request for the chunk
	Chunk                *PieceDownloadRequest_Chunk `protobuf:"bytes,3,opt,name=chunk,proto3" json:"chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PieceDownloadRequest) Reset()         { *m = PieceDownloadRequest{} }
func (m *PieceDownloadRequest) String() string { return proto.CompactTextString(m) }
func (*PieceDownloadRequest) ProtoMessage()    {}
func (*PieceDownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{2}
}
func (m *PieceDownloadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceDownloadRequest.Unmarshal(m, b)
}
func (m *PieceDownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceDownloadRequest.Marshal(b, m, deterministic)
}
func (m *PieceDownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceDownloadRequest.Merge(m, src)
}
func (m *PieceDownloadRequest) XXX_Size() int {
	return xxx_messageInfo_PieceDownloadRequest.Size(m)
}
func (m *PieceDownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceDownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PieceDownloadRequest proto.InternalMessageInfo

func (m *PieceDownloadRequest) GetLimit() *OrderLimit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *PieceDownloadRequest) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *PieceDownloadRequest) GetChunk() *PieceDownloadRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// Chunk that we wish to download
type PieceDownloadRequest_Chunk struct {
	Offset               int64    `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	ChunkSize            int64    `protobuf:"varint,2,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceDownloadRequest_Chunk) Reset()         { *m = PieceDownloadRequest_Chunk{} }
func (m *PieceDownloadRequest_Chunk) String() string { return proto.CompactTextString(m) }
func (*PieceDownloadRequest_Chunk) ProtoMessage()    {}
func (*PieceDownloadRequest_Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{2, 0}
}
func (m *PieceDownloadRequest_Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceDownloadRequest_Chunk.Unmarshal(m, b)
}
func (m *PieceDownloadRequest_Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceDownloadRequest_Chunk.Marshal(b, m, deterministic)
}
func (m *PieceDownloadRequest_Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceDownloadRequest_Chunk.Merge(m, src)
}
func (m *PieceDownloadRequest_Chunk) XXX_Size() int {
	return xxx_messageInfo_PieceDownloadRequest_Chunk.Size(m)
}
func (m *PieceDownloadRequest_Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceDownloadRequest_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_PieceDownloadRequest_Chunk proto.InternalMessageInfo

func (m *PieceDownloadRequest_Chunk) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PieceDownloadRequest_Chunk) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

type PieceDownloadResponse struct {
	Chunk                *PieceDownloadResponse_Chunk `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
	Hash                 *PieceHash                   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Limit                *OrderLimit                  `protobuf:"bytes,3,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *PieceDownloadResponse) Reset()         { *m = PieceDownloadResponse{} }
func (m *PieceDownloadResponse) String() string { return proto.CompactTextString(m) }
func (*PieceDownloadResponse) ProtoMessage()    {}
func (*PieceDownloadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{3}
}
func (m *PieceDownloadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceDownloadResponse.Unmarshal(m, b)
}
func (m *PieceDownloadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceDownloadResponse.Marshal(b, m, deterministic)
}
func (m *PieceDownloadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceDownloadResponse.Merge(m, src)
}
func (m *PieceDownloadResponse) XXX_Size() int {
	return xxx_messageInfo_PieceDownloadResponse.Size(m)
}
func (m *PieceDownloadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceDownloadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PieceDownloadResponse proto.InternalMessageInfo

func (m *PieceDownloadResponse) GetChunk() *PieceDownloadResponse_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *PieceDownloadResponse) GetHash() *PieceHash {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *PieceDownloadResponse) GetLimit() *OrderLimit {
	if m != nil {
		return m.Limit
	}
	return nil
}

// Chunk response for download request
type PieceDownloadResponse_Chunk struct {
	Offset               int64    `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceDownloadResponse_Chunk) Reset()         { *m = PieceDownloadResponse_Chunk{} }
func (m *PieceDownloadResponse_Chunk) String() string { return proto.CompactTextString(m) }
func (*PieceDownloadResponse_Chunk) ProtoMessage()    {}
func (*PieceDownloadResponse_Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{3, 0}
}
func (m *PieceDownloadResponse_Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceDownloadResponse_Chunk.Unmarshal(m, b)
}
func (m *PieceDownloadResponse_Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceDownloadResponse_Chunk.Marshal(b, m, deterministic)
}
func (m *PieceDownloadResponse_Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceDownloadResponse_Chunk.Merge(m, src)
}
func (m *PieceDownloadResponse_Chunk) XXX_Size() int {
	return xxx_messageInfo_PieceDownloadResponse_Chunk.Size(m)
}
func (m *PieceDownloadResponse_Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceDownloadResponse_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_PieceDownloadResponse_Chunk proto.InternalMessageInfo

func (m *PieceDownloadResponse_Chunk) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PieceDownloadResponse_Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type PieceDeleteRequest struct {
	Limit                *OrderLimit `protobuf:"bytes,1,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PieceDeleteRequest) Reset()         { *m = PieceDeleteRequest{} }
func (m *PieceDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*PieceDeleteRequest) ProtoMessage()    {}
func (*PieceDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{4}
}
func (m *PieceDeleteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceDeleteRequest.Unmarshal(m, b)
}
func (m *PieceDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceDeleteRequest.Marshal(b, m, deterministic)
}
func (m *PieceDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceDeleteRequest.Merge(m, src)
}
func (m *PieceDeleteRequest) XXX_Size() int {
	return xxx_messageInfo_PieceDeleteRequest.Size(m)
}
func (m *PieceDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PieceDeleteRequest proto.InternalMessageInfo

func (m *PieceDeleteRequest) GetLimit() *OrderLimit {
	if m != nil {
		return m.Limit
	}
	return nil
}

type PieceDeleteResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceDeleteResponse) Reset()         { *m = PieceDeleteResponse{} }
func (m *PieceDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*PieceDeleteResponse) ProtoMessage()    {}
func (*PieceDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{5}
}
func (m *PieceDeleteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceDeleteResponse.Unmarshal(m, b)
}
func (m *PieceDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceDeleteResponse.Marshal(b, m, deterministic)
}
func (m *PieceDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceDeleteResponse.Merge(m, src)
}
func (m *PieceDeleteResponse) XXX_Size() int {
	return xxx_messageInfo_PieceDeleteResponse.Size(m)
}
func (m *PieceDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PieceDeleteResponse proto.InternalMessageInfo

type RetainRequest struct {
	CreationDate         time.Time `protobuf:"bytes,1,opt,name=creation_date,json=creationDate,proto3,stdtime" json:"creation_date"`
	Filter               []byte    `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RetainRequest) Reset()         { *m = RetainRequest{} }
func (m *RetainRequest) String() string { return proto.CompactTextString(m) }
func (*RetainRequest) ProtoMessage()    {}
func (*RetainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{6}
}
func (m *RetainRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RetainRequest.Unmarshal(m, b)
}
func (m *RetainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RetainRequest.Marshal(b, m, deterministic)
}
func (m *RetainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetainRequest.Merge(m, src)
}
func (m *RetainRequest) XXX_Size() int {
	return xxx_messageInfo_RetainRequest.Size(m)
}
func (m *RetainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RetainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RetainRequest proto.InternalMessageInfo

func (m *RetainRequest) GetCreationDate() time.Time {
	if m != nil {
		return m.CreationDate
	}
	return time.Time{}
}

func (m *RetainRequest) GetFilter() []byte {
	if m != nil {
		return m.Filter
	}
	return nil
}

type RetainResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RetainResponse) Reset()         { *m = RetainResponse{} }
func (m *RetainResponse) String() string { return proto.CompactTextString(m) }
func (*RetainResponse) ProtoMessage()    {}
func (*RetainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{7}
}
func (m *RetainResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RetainResponse.Unmarshal(m, b)
}
func (m *RetainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RetainResponse.Marshal(b, m, deterministic)
}
func (m *RetainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetainResponse.Merge(m, src)
}
func (m *RetainResponse) XXX_Size() int {
	return xxx_messageInfo_RetainResponse.Size(m)
}
func (m *RetainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RetainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RetainResponse proto.InternalMessageInfo

// PieceHeader is used in piece storage to keep track of piece attributes.
type PieceHeader struct {
	// the storage format version being used for this piece. The piece filename should agree with this.
	// The inclusion of this field is intended to aid repairability when filenames are damaged.
	FormatVersion PieceHeader_FormatVersion `protobuf:"varint,1,opt,name=format_version,json=formatVersion,proto3,enum=piecestore.PieceHeader_FormatVersion" json:"format_version,omitempty"`
	// content hash of the piece
	Hash []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// timestamp when upload occurred, as given by the "timestamp" field in the original orders.PieceHash
	CreationTime time.Time `protobuf:"bytes,3,opt,name=creation_time,json=creationTime,proto3,stdtime" json:"creation_time"`
	// signature from uplink over the original orders.PieceHash (the corresponding PieceHashSigning
	// is reconstructable using the piece id from the piecestore, the piece size from the
	// filesystem (minus the piece header size), and these (hash, upload_time, signature) fields).
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// the OrderLimit authorizing storage of this piece, as signed by the satellite and sent by
	// the uplink
	OrderLimit           OrderLimit `protobuf:"bytes,5,opt,name=order_limit,json=orderLimit,proto3" json:"order_limit"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PieceHeader) Reset()         { *m = PieceHeader{} }
func (m *PieceHeader) String() string { return proto.CompactTextString(m) }
func (*PieceHeader) ProtoMessage()    {}
func (*PieceHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_23ff32dd550c2439, []int{8}
}
func (m *PieceHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PieceHeader.Unmarshal(m, b)
}
func (m *PieceHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PieceHeader.Marshal(b, m, deterministic)
}
func (m *PieceHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceHeader.Merge(m, src)
}
func (m *PieceHeader) XXX_Size() int {
	return xxx_messageInfo_PieceHeader.Size(m)
}
func (m *PieceHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceHeader.DiscardUnknown(m)
}

var xxx_messageInfo_PieceHeader proto.InternalMessageInfo

func (m *PieceHeader) GetFormatVersion() PieceHeader_FormatVersion {
	if m != nil {
		return m.FormatVersion
	}
	return PieceHeader_FORMAT_V0
}

func (m *PieceHeader) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *PieceHeader) GetCreationTime() time.Time {
	if m != nil {
		return m.CreationTime
	}
	return time.Time{}
}

func (m *PieceHeader) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *PieceHeader) GetOrderLimit() OrderLimit {
	if m != nil {
		return m.OrderLimit
	}
	return OrderLimit{}
}

func init() {
	proto.RegisterEnum("piecestore.PieceHeader_FormatVersion", PieceHeader_FormatVersion_name, PieceHeader_FormatVersion_value)
	proto.RegisterType((*PieceUploadRequest)(nil), "piecestore.PieceUploadRequest")
	proto.RegisterType((*PieceUploadRequest_Chunk)(nil), "piecestore.PieceUploadRequest.Chunk")
	proto.RegisterType((*PieceUploadResponse)(nil), "piecestore.PieceUploadResponse")
	proto.RegisterType((*PieceDownloadRequest)(nil), "piecestore.PieceDownloadRequest")
	proto.RegisterType((*PieceDownloadRequest_Chunk)(nil), "piecestore.PieceDownloadRequest.Chunk")
	proto.RegisterType((*PieceDownloadResponse)(nil), "piecestore.PieceDownloadResponse")
	proto.RegisterType((*PieceDownloadResponse_Chunk)(nil), "piecestore.PieceDownloadResponse.Chunk")
	proto.RegisterType((*PieceDeleteRequest)(nil), "piecestore.PieceDeleteRequest")
	proto.RegisterType((*PieceDeleteResponse)(nil), "piecestore.PieceDeleteResponse")
	proto.RegisterType((*RetainRequest)(nil), "piecestore.RetainRequest")
	proto.RegisterType((*RetainResponse)(nil), "piecestore.RetainResponse")
	proto.RegisterType((*PieceHeader)(nil), "piecestore.PieceHeader")
}

func init() { proto.RegisterFile("piecestore2.proto", fileDescriptor_23ff32dd550c2439) }

var fileDescriptor_23ff32dd550c2439 = []byte{
	// 648 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcb, 0x6e, 0xd3, 0x4c,
	0x14, 0x8e, 0x73, 0x53, 0x7b, 0x6a, 0x57, 0xed, 0xfc, 0x7f, 0x51, 0xb0, 0x80, 0x14, 0x43, 0xa1,
	0x1b, 0xdc, 0x92, 0xae, 0x40, 0xa5, 0x88, 0x52, 0x55, 0x20, 0x5a, 0xb5, 0x1a, 0xda, 0x2e, 0xd8,
	0x44, 0x93, 0x64, 0x9c, 0x58, 0x24, 0x1e, 0xe3, 0x99, 0x80, 0xd4, 0xa7, 0xe0, 0x91, 0x10, 0x2b,
	0x1e, 0x02, 0xc1, 0x82, 0xc7, 0x60, 0x83, 0xe6, 0xe2, 0x24, 0x4e, 0xd2, 0x44, 0x45, 0x62, 0x95,
	0xcc, 0xb9, 0x9f, 0xef, 0xfb, 0x8e, 0x61, 0x35, 0x0e, 0x69, 0x93, 0x72, 0xc1, 0x12, 0x5a, 0xf3,
	0xe3, 0x84, 0x09, 0x86, 0x60, 0x68, 0x72, 0xa1, 0xcd, 0xda, 0x4c, 0xdb, 0xdd, 0x6a, 0x9b, 0xb1,
	0x76, 0x97, 0x6e, 0xa9, 0x57, 0xa3, 0x1f, 0x6c, 0x89, 0xb0, 0x47, 0xb9, 0x20, 0xbd, 0xd8, 0x04,
	0xd8, 0x2c, 0x69, 0xd1, 0x84, 0xeb, 0x97, 0xf7, 0xdb, 0x02, 0x74, 0x2a, 0x2b, 0x9d, 0xc7, 0x5d,
	0x46, 0x5a, 0x98, 0x7e, 0xe8, 0x53, 0x2e, 0xd0, 0x26, 0x94, 0xba, 0x61, 0x2f, 0x14, 0x15, 0x6b,
	0xdd, 0xda, 0x5c, 0xaa, 0x21, 0xdf, 0x24, 0x9d, 0xc8, 0x9f, 0x23, 0xe9, 0xc1, 0x3a, 0x00, 0xdd,
	0x83, 0x92, 0xf2, 0x55, 0xf2, 0x2a, 0xd2, 0xc9, 0x44, 0x62, 0xed, 0x43, 0x4f, 0xa1, 0xd4, 0xec,
	0xf4, 0xa3, 0xf7, 0x95, 0x82, 0x0a, 0xba, 0xef, 0x0f, 0x87, 0xf7, 0x27, 0xbb, 0xfb, 0x2f, 0x65,
	0x2c, 0xd6, 0x29, 0x68, 0x03, 0x8a, 0x2d, 0x16, 0xd1, 0x4a, 0x51, 0xa5, 0xae, 0xa6, 0xf5, 0x55,
	0xda, 0x2b, 0xc2, 0x3b, 0x58, 0xb9, 0xdd, 0x1d, 0x28, 0xa9, 0x34, 0x74, 0x03, 0xca, 0x2c, 0x08,
	0x38, 0xd5, 0xb3, 0x17, 0xb0, 0x79, 0x21, 0x04, 0xc5, 0x16, 0x11, 0x44, 0xcd, 0x69, 0x63, 0xf5,
	0xdf, 0xdb, 0x85, 0xff, 0x32, 0xed, 0x79, 0xcc, 0x22, 0x4e, 0x07, 0x2d, 0xad, 0x99, 0x2d, 0xbd,
	0x5f, 0x16, 0xfc, 0xaf, 0x6c, 0x07, 0xec, 0x53, 0xf4, 0x0f, 0xd1, 0xdb, 0xcd, 0xa2, 0xf7, 0x60,
	0x02, 0xbd, 0xb1, 0xfe, 0x19, 0xfc, 0xdc, 0xbd, 0x79, 0xc0, 0xdc, 0x06, 0x50, 0x91, 0x75, 0x1e,
	0x5e, 0x52, 0x35, 0x48, 0x01, 0x2f, 0x2a, 0xcb, 0xdb, 0xf0, 0x92, 0x7a, 0xdf, 0x2d, 0x58, 0x1b,
	0xeb, 0x62, 0x60, 0x7a, 0x96, 0xce, 0xa5, 0xd7, 0x7c, 0x38, 0x63, 0x2e, 0x9d, 0x31, 0x41, 0x6c,
	0x87, 0xf0, 0x8e, 0x59, 0x7d, 0x1a, 0xca, 0xd2, 0x3d, 0x04, 0xb3, 0x30, 0x07, 0xcc, 0xbf, 0x93,
	0xc0, 0x9e, 0xd1, 0xff, 0x01, 0xed, 0x52, 0x41, 0xaf, 0xcd, 0xa0, 0xb7, 0x66, 0x24, 0x94, 0xe6,
	0xeb, 0x4d, 0xbd, 0x04, 0x1c, 0x4c, 0x05, 0x09, 0xa3, 0xb4, 0xe2, 0x6b, 0x70, 0x9a, 0x09, 0x25,
	0x22, 0x64, 0x51, 0xbd, 0x45, 0x44, 0x2a, 0x2e, 0xd7, 0xd7, 0xf7, 0xea, 0xa7, 0xf7, 0xea, 0x9f,
	0xa5, 0xf7, 0xba, 0xbf, 0xf0, 0xed, 0x47, 0x35, 0xf7, 0xf9, 0x67, 0xd5, 0xc2, 0x76, 0x9a, 0x7a,
	0x40, 0x04, 0x95, 0xeb, 0x05, 0x61, 0x57, 0x18, 0xd5, 0xd8, 0xd8, 0xbc, 0xbc, 0x15, 0x58, 0x4e,
	0x7b, 0x9a, 0x29, 0xbe, 0xe6, 0x61, 0x49, 0xe3, 0x49, 0x89, 0x54, 0xd2, 0x11, 0x2c, 0x07, 0x2c,
	0xe9, 0x11, 0x51, 0xff, 0x48, 0x13, 0x1e, 0xb2, 0x48, 0x4d, 0xb1, 0x5c, 0xdb, 0x98, 0xa0, 0x4e,
	0x27, 0xf8, 0x87, 0x2a, 0xfa, 0x42, 0x07, 0x63, 0x27, 0x18, 0x7d, 0x4a, 0x38, 0x07, 0x04, 0xda,
	0x86, 0xad, 0xd1, 0x35, 0xe5, 0x97, 0xc7, 0xb0, 0x76, 0xcd, 0x35, 0xa5, 0x13, 0xdd, 0x82, 0x45,
	0x1e, 0xb6, 0x23, 0x22, 0xfa, 0x89, 0xbe, 0x7e, 0x1b, 0x0f, 0x0d, 0xe8, 0x09, 0x2c, 0x29, 0x4e,
	0xea, 0x9a, 0xa7, 0xd2, 0x55, 0x3c, 0xed, 0x17, 0x65, 0x79, 0x0c, 0x6c, 0x60, 0xf1, 0x1e, 0x81,
	0x93, 0xd9, 0x0b, 0x39, 0xb0, 0x78, 0x78, 0x82, 0x8f, 0x5f, 0x9c, 0xd5, 0x2f, 0xb6, 0x57, 0x72,
	0xa3, 0xcf, 0xc7, 0x2b, 0x56, 0xed, 0x4b, 0x1e, 0xe0, 0x74, 0x00, 0x0f, 0x3a, 0x86, 0xb2, 0xfe,
	0x5c, 0xa0, 0x3b, 0xb3, 0x3f, 0x63, 0x6e, 0xf5, 0x4a, 0xbf, 0xa1, 0x27, 0xb7, 0x69, 0xa1, 0x73,
	0x58, 0x48, 0xcf, 0x04, 0xad, 0xcf, 0xbb, 0x6c, 0xf7, 0xee, 0xdc, 0x1b, 0x93, 0x45, 0xb7, 0x2d,
	0xf4, 0x06, 0xca, 0x5a, 0x91, 0x53, 0xa6, 0xcc, 0x48, 0x7d, 0xca, 0x94, 0x63, 0x52, 0xce, 0xa1,
	0xe7, 0x50, 0xd6, 0xc2, 0x42, 0x37, 0x47, 0x83, 0x33, 0x02, 0x77, 0xdd, 0x69, 0x2e, 0x5d, 0x62,
	0xbf, 0xf8, 0x2e, 0x1f, 0x37, 0x1a, 0x65, 0x45, 0xfe, 0xce, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x8a, 0x5d, 0xb7, 0x8b, 0xce, 0x06, 0x00, 0x00,
}

type DRPCPiecestoreClient interface {
	DRPCConn() drpc.Conn

	Upload(ctx context.Context) (DRPCPiecestore_UploadClient, error)
	Download(ctx context.Context) (DRPCPiecestore_DownloadClient, error)
	Delete(ctx context.Context, in *PieceDeleteRequest) (*PieceDeleteResponse, error)
	Retain(ctx context.Context, in *RetainRequest) (*RetainResponse, error)
}

type drpcPiecestoreClient struct {
	cc drpc.Conn
}

func NewDRPCPiecestoreClient(cc drpc.Conn) DRPCPiecestoreClient {
	return &drpcPiecestoreClient{cc}
}

func (c *drpcPiecestoreClient) DRPCConn() drpc.Conn { return c.cc }

func (c *drpcPiecestoreClient) Upload(ctx context.Context) (DRPCPiecestore_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, "/piecestore.Piecestore/Upload")
	if err != nil {
		return nil, err
	}
	x := &drpcPiecestoreUploadClient{stream}
	return x, nil
}

type DRPCPiecestore_UploadClient interface {
	drpc.Stream
	Send(*PieceUploadRequest) error
	CloseAndRecv() (*PieceUploadResponse, error)
}

type drpcPiecestoreUploadClient struct {
	drpc.Stream
}

func (x *drpcPiecestoreUploadClient) Send(m *PieceUploadRequest) error {
	return x.MsgSend(m)
}

func (x *drpcPiecestoreUploadClient) CloseAndRecv() (*PieceUploadResponse, error) {
	if err := x.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PieceUploadResponse)
	if err := x.MsgRecv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *drpcPiecestoreClient) Download(ctx context.Context) (DRPCPiecestore_DownloadClient, error) {
	stream, err := c.cc.NewStream(ctx, "/piecestore.Piecestore/Download")
	if err != nil {
		return nil, err
	}
	x := &drpcPiecestoreDownloadClient{stream}
	return x, nil
}

type DRPCPiecestore_DownloadClient interface {
	drpc.Stream
	Send(*PieceDownloadRequest) error
	Recv() (*PieceDownloadResponse, error)
}

type drpcPiecestoreDownloadClient struct {
	drpc.Stream
}

func (x *drpcPiecestoreDownloadClient) Send(m *PieceDownloadRequest) error {
	return x.MsgSend(m)
}

func (x *drpcPiecestoreDownloadClient) Recv() (*PieceDownloadResponse, error) {
	m := new(PieceDownloadResponse)
	if err := x.MsgRecv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *drpcPiecestoreClient) Delete(ctx context.Context, in *PieceDeleteRequest) (*PieceDeleteResponse, error) {
	out := new(PieceDeleteResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/Delete", in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drpcPiecestoreClient) Retain(ctx context.Context, in *RetainRequest) (*RetainResponse, error) {
	out := new(RetainResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/Retain", in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type DRPCPiecestoreServer interface {
	Upload(DRPCPiecestore_UploadStream) error
	Download(DRPCPiecestore_DownloadStream) error
	Delete(context.Context, *PieceDeleteRequest) (*PieceDeleteResponse, error)
	Retain(context.Context, *RetainRequest) (*RetainResponse, error)
}

type DRPCPiecestoreDescription struct{}

func (DRPCPiecestoreDescription) NumMethods() int { return 4 }

func (DRPCPiecestoreDescription) Method(n int) (string, drpc.Handler, interface{}, bool) {
	switch n {
	case 0:
		return "/piecestore.Piecestore/Upload",
			func(srv interface{}, ctx context.Context, in1, in2 interface{}) (drpc.Message, error) {
				return nil, srv.(DRPCPiecestoreServer).
					Upload(
						&drpcPiecestoreUploadStream{in1.(drpc.Stream)},
					)
			}, DRPCPiecestoreServer.Upload, true
	case 1:
		return "/piecestore.Piecestore/Download",
			func(srv interface{}, ctx context.Context, in1, in2 interface{}) (drpc.Message, error) {
				return nil, srv.(DRPCPiecestoreServer).
					Download(
						&drpcPiecestoreDownloadStream{in1.(drpc.Stream)},
					)
			}, DRPCPiecestoreServer.Download, true
	case 2:
		return "/piecestore.Piecestore/Delete",
			func(srv interface{}, ctx context.Context, in1, in2 interface{}) (drpc.Message, error) {
				return srv.(DRPCPiecestoreServer).
					Delete(
						ctx,
						in1.(*PieceDeleteRequest),
					)
			}, DRPCPiecestoreServer.Delete, true
	case 3:
		return "/piecestore.Piecestore/Retain",
			func(srv interface{}, ctx context.Context, in1, in2 interface{}) (drpc.Message, error) {
				return srv.(DRPCPiecestoreServer).
					Retain(
						ctx,
						in1.(*RetainRequest),
					)
			}, DRPCPiecestoreServer.Retain, true
	default:
		return "", nil, nil, false
	}
}

func DRPCRegisterPiecestore(srv drpc.Server, impl DRPCPiecestoreServer) {
	srv.Register(impl, DRPCPiecestoreDescription{})
}

type DRPCPiecestore_UploadStream interface {
	drpc.Stream
	SendAndClose(*PieceUploadResponse) error
	Recv() (*PieceUploadRequest, error)
}

type drpcPiecestoreUploadStream struct {
	drpc.Stream
}

func (x *drpcPiecestoreUploadStream) SendAndClose(m *PieceUploadResponse) error {
	if err := x.MsgSend(m); err != nil {
		return err
	}
	return x.CloseSend()
}

func (x *drpcPiecestoreUploadStream) Recv() (*PieceUploadRequest, error) {
	m := new(PieceUploadRequest)
	if err := x.MsgRecv(m); err != nil {
		return nil, err
	}
	return m, nil
}

type DRPCPiecestore_DownloadStream interface {
	drpc.Stream
	Send(*PieceDownloadResponse) error
	Recv() (*PieceDownloadRequest, error)
}

type drpcPiecestoreDownloadStream struct {
	drpc.Stream
}

func (x *drpcPiecestoreDownloadStream) Send(m *PieceDownloadResponse) error {
	return x.MsgSend(m)
}

func (x *drpcPiecestoreDownloadStream) Recv() (*PieceDownloadRequest, error) {
	m := new(PieceDownloadRequest)
	if err := x.MsgRecv(m); err != nil {
		return nil, err
	}
	return m, nil
}

type DRPCPiecestore_DeleteStream interface {
	drpc.Stream
	SendAndClose(*PieceDeleteResponse) error
}

type drpcPiecestoreDeleteStream struct {
	drpc.Stream
}

func (x *drpcPiecestoreDeleteStream) SendAndClose(m *PieceDeleteResponse) error {
	if err := x.MsgSend(m); err != nil {
		return err
	}
	return x.CloseSend()
}

type DRPCPiecestore_RetainStream interface {
	drpc.Stream
	SendAndClose(*RetainResponse) error
}

type drpcPiecestoreRetainStream struct {
	drpc.Stream
}

func (x *drpcPiecestoreRetainStream) SendAndClose(m *RetainResponse) error {
	if err := x.MsgSend(m); err != nil {
		return err
	}
	return x.CloseSend()
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PiecestoreClient is the client API for Piecestore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PiecestoreClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (Piecestore_UploadClient, error)
	Download(ctx context.Context, opts ...grpc.CallOption) (Piecestore_DownloadClient, error)
	Delete(ctx context.Context, in *PieceDeleteRequest, opts ...grpc.CallOption) (*PieceDeleteResponse, error)
	Retain(ctx context.Context, in *RetainRequest, opts ...grpc.CallOption) (*RetainResponse, error)
}

type piecestoreClient struct {
	cc *grpc.ClientConn
}

func NewPiecestoreClient(cc *grpc.ClientConn) PiecestoreClient {
	return &piecestoreClient{cc}
}

func (c *piecestoreClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Piecestore_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Piecestore_serviceDesc.Streams[0], "/piecestore.Piecestore/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &piecestoreUploadClient{stream}
	return x, nil
}

type Piecestore_UploadClient interface {
	Send(*PieceUploadRequest) error
	CloseAndRecv() (*PieceUploadResponse, error)
	grpc.ClientStream
}

type piecestoreUploadClient struct {
	grpc.ClientStream
}

func (x *piecestoreUploadClient) Send(m *PieceUploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *piecestoreUploadClient) CloseAndRecv() (*PieceUploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PieceUploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *piecestoreClient) Download(ctx context.Context, opts ...grpc.CallOption) (Piecestore_DownloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Piecestore_serviceDesc.Streams[1], "/piecestore.Piecestore/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &piecestoreDownloadClient{stream}
	return x, nil
}

type Piecestore_DownloadClient interface {
	Send(*PieceDownloadRequest) error
	Recv() (*PieceDownloadResponse, error)
	grpc.ClientStream
}

type piecestoreDownloadClient struct {
	grpc.ClientStream
}

func (x *piecestoreDownloadClient) Send(m *PieceDownloadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *piecestoreDownloadClient) Recv() (*PieceDownloadResponse, error) {
	m := new(PieceDownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *piecestoreClient) Delete(ctx context.Context, in *PieceDeleteRequest, opts ...grpc.CallOption) (*PieceDeleteResponse, error) {
	out := new(PieceDeleteResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *piecestoreClient) Retain(ctx context.Context, in *RetainRequest, opts ...grpc.CallOption) (*RetainResponse, error) {
	out := new(RetainResponse)
	err := c.cc.Invoke(ctx, "/piecestore.Piecestore/Retain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PiecestoreServer is the server API for Piecestore service.
type PiecestoreServer interface {
	Upload(Piecestore_UploadServer) error
	Download(Piecestore_DownloadServer) error
	Delete(context.Context, *PieceDeleteRequest) (*PieceDeleteResponse, error)
	Retain(context.Context, *RetainRequest) (*RetainResponse, error)
}

func RegisterPiecestoreServer(s *grpc.Server, srv PiecestoreServer) {
	s.RegisterService(&_Piecestore_serviceDesc, srv)
}

func _Piecestore_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PiecestoreServer).Upload(&piecestoreUploadServer{stream})
}

type Piecestore_UploadServer interface {
	SendAndClose(*PieceUploadResponse) error
	Recv() (*PieceUploadRequest, error)
	grpc.ServerStream
}

type piecestoreUploadServer struct {
	grpc.ServerStream
}

func (x *piecestoreUploadServer) SendAndClose(m *PieceUploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *piecestoreUploadServer) Recv() (*PieceUploadRequest, error) {
	m := new(PieceUploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Piecestore_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PiecestoreServer).Download(&piecestoreDownloadServer{stream})
}

type Piecestore_DownloadServer interface {
	Send(*PieceDownloadResponse) error
	Recv() (*PieceDownloadRequest, error)
	grpc.ServerStream
}

type piecestoreDownloadServer struct {
	grpc.ServerStream
}

func (x *piecestoreDownloadServer) Send(m *PieceDownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *piecestoreDownloadServer) Recv() (*PieceDownloadRequest, error) {
	m := new(PieceDownloadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Piecestore_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PieceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PiecestoreServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/piecestore.Piecestore/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PiecestoreServer).Delete(ctx, req.(*PieceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Piecestore_Retain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PiecestoreServer).Retain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/piecestore.Piecestore/Retain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PiecestoreServer).Retain(ctx, req.(*RetainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Piecestore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "piecestore.Piecestore",
	HandlerType: (*PiecestoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Piecestore_Delete_Handler,
		},
		{
			MethodName: "Retain",
			Handler:    _Piecestore_Retain_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Piecestore_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Download",
			Handler:       _Piecestore_Download_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "piecestore2.proto",
}
